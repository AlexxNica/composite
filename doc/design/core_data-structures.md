_Composite_ Data-Structures and Invocation Path
===============================================

This document briefly details the main data-structures in the
_Composite_ kernel, and the invocation path between components.

Kernel Data-Structures
----------------------

<center>
![Composite data structures](http://www.seas.gwu.edu/~gparmer/data_structures.png)
</center>

The main data-structures include:

- `spd` : Each component is described by a `struct spd`.  Not shown
  are the page tables that are referenced by the `spd`.  Also included
  in the `spd` is a list of extents of valid virtual addresses for the
  component, a list of capabilities that are associated with specific
  faults (i.e. capabilities that should be invoked if that fault
  occurs), a base and extent of the capabilities accessible by the
  `spd`, and other fields.

- `thread` : The thread structure includes a stack of
  `thd_invocation_frame`s, and the `stack_ptr` indexes the top of the
  stack.  This structure acts as a stack of invocations; the bottom of
  the stack is the component that the thread begins execution in, and
  when a component is invoked, a reference to it is pushed on the
  stack.  When an invoked function in the interface of a component
  returns, it pops an item off of the stack to expose the new head,
  and current component.  Not shown here, an invocation frame holds
  the instruction and stack pointers to return to the previous
  component.

- `invocation_cap` : When an invocation is made, the component making
  the invocation specifies a *capability* corresponding to a function
  in the interface of the invoked component.  Each `invocation_cap`
  specifies the component that _owns_ it, the _destination_ component
  of the invocation, and the instruction pointer to begin execution
  at.  Additionally, each capability has a corresponding user-level
  `usr_inv_cap` that includes not only the capability number to pass
  to the kernel, and a function pointer to call to mediate the
  invocation.

- `virtual_spd_layout` : Currently, _Composite_ is a single
  address-space OS.  Components don't overlap in virtual
  addresses. The `virtual_spd_layout` is an array with each entry
  corresponding to a 4MB region of virtual address range, and pointing
  to the `spd` that owns that region.

The Invocation Operation
------------------------

A client component executing in a function (e.g. `main`) calls a
function (e.g. `fn`).  The procedure for this operation follows:

- The loading process makes such an invocation execute code generated
  by `src/platform/linux/link_load/gen_client_stub.c`.  This code
  parses the `usr_inv_cap` and retrieves both the capability number,
  and the function pointer to call to conduct the invocation.  This
  code is dynamically generated by the `cos_loader`.

- If both components are in the same protection domain (via Mutable
  Protection Domains), then this function pointer points directly to
  `fn`, thus making its invocation have very little overhead.
  Otherwise, a stub function is invoked.

- The stub's job is to marshall any arguments that cannot be passed in
  4 registers, and invoke the kernel.  These clients stubs are defined
  in `src/components/interface/*/stubs/c_stub.c`.  If a function does
  not require more than 4 scalar arguments, then the default stub can
  be used in `src/components/lib/c_stub.S`.  This code uses `sysenter`
  to call the kernel.

- Once in the kernel, execution begins in
  `src/platform/linux/module/kern_entry.S:sysenter_interposition_entry`
  which calls `src/platform/linux/module/ipc.S:composite_call_ipc`.
  This assembly function calls the
  `src/kernel/inv.c:ipc_walk_static_cap` function.  This is the main
  logic that will 1) parse through the capability specified to find
  the destination component and entry instruction, 2) switch
  protection domains (by writing to `cr3`), and 3) pushes onto the
  thread's invocation stack the new component.

- An upcall is triggered at that address in the invoked component and
  execution begins at another stub that demarshals the arguments,
  `src/components/interface/*/stubs/s_stub.S`.  If defined, an
  additional `c` stub is called in
  `src/components/interface/*/stubs/s_cstub.c`.  These call the actual
  function itself.

- When the function returns it reverses course through all of these
  actions.  In the kernel, control flows through
  `src/platform/linux/module/kern_entry.S:sysenter_interposition_entry`,
  then `src/platform/linux/module/ipc.S:composite_ret_ipc` that in
  turn calls `src/kernel/inv.c:pop`.  This function pops an item off
  of the invocation stack, switches protection domains, and restores
  the stack and instruction pointers in the calling component that
  were saved in the stack.

Future Changes
--------------

In the future, we will probably make the capability table per-`spd`,
thus index into a local table for each component.

